<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 4px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* --- Button system (for both <button> and <a>) --- */
        button,
        .btn {
            display: inline-block;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-decoration: none;
        }
        button:hover,
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        button:active,
        .btn:active {
            transform: translateY(0);
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            color: white;
        }
        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #bdc3c7 0%, #2c3e50 100%);
            color: white;
        }
        /* Themed GitHub button */
        .btn-github {
            background: linear-gradient(135deg, #24292e 0%, #2c3e50 100%);
            color: #fff;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            max-width: 1200px;
            width: 100%;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            background: white;
        }
        select:focus { outline: none; border-color: #667eea; }
        
        label { font-weight: 600; color: #333; }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] { width: 200px; }
        
        .grid-container {
            display: inline-block;
            border: 2px solid #333;
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .grid {
            display: grid;
            gap: 1px;
            background: #ccc;
        }
        
        .cell {
            width: 25px;
            height: 25px;
            background: white;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        
        .cell.wall { background: #2c3e50; }
        .cell.start { background: #56ab2f; }
        .cell.end { background: #eb3349; }
        
        .cell.visited {
            background: #74b9ff;
            animation: visitedAnimation 0.3s ease-out;
        }
        .cell.path {
            background: #ffd700;
            animation: pathAnimation 0.5s ease-out;
        }
        
        @keyframes visitedAnimation {
            0% { transform: scale(0.3); background: #dfe6e9; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        @keyframes pathAnimation {
            0% { transform: scale(0.6); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-box {
            width: 20px; height: 20px; border: 1px solid #333; border-radius: 3px;
        }
        
        .stats {
            display: flex;
            gap: 30px;
            margin-top: 16px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .stat-item { display: flex; flex-direction: column; }
        .stat-label {
            font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .stat-value { font-size: 20px; font-weight: bold; color: #333; }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }
        .instructions h3 { margin-bottom: 10px; color: #333; }
        .instructions ul { margin-left: 20px; color: #555; }
        .instructions li { margin: 5px 0; }

        /* Algorithm blurb panel */
        .algo-blurb {
            margin-top: 12px;
            padding: 12px 14px;
            background: #faf7ff;
            border: 1px solid rgba(102, 126, 234, 0.35);
            border-radius: 8px;
            color: #2c2c54;
            line-height: 1.4;
        }
        .algo-blurb strong { color: #4c51bf; }
    </style>
</head>
<body>
    <header>
        <h1>Pathfinding Visualizer</h1>
        <p class="subtitle">Watch algorithms find the shortest path in real-time</p>
        <!-- THEMED GitHub button -->
        <a href="https://github.com/Chaotic-Mess/My-Code-" class="btn btn-github" target="_blank" rel="noopener noreferrer" title="Open repository in a new tab">Return to GitHub</a>
    </header>
    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="algorithm">Algorithm:</label>
                <select id="algorithm">
                    <option value="astar">A* Search</option>
                    <option value="dijkstra">Dijkstra</option>
                    <option value="bfs">Breadth-First Search</option>
                    <option value="dfs">Depth-First Search</option>
                </select>
            </div>
            
            <button class="btn-primary" id="visualize">Visualize</button>
            <button class="btn-success" id="generateMaze">Generate Maze</button>
            <button class="btn-danger" id="clearPath">Clear Path</button>
            <button class="btn-secondary" id="clearAll">Clear All</button>
            
            <div class="speed-control">
                <label for="timescale">Timescale:</label>
                <!-- 0.1× (slow) … 20× (very fast); 1× ≈ old 25ms/step -->
                <input type="range" id="timescale" min="0.1" max="20" step="0.1" value="1">
                <span id="speedValue">1× (~25ms/step)</span>
            </div>
        </div>

        <!-- Algorithm description (chatty + clear) -->
        <div class="algo-blurb" id="algoBlurb">
            <strong>A* Search:</strong> the overachiever with a compass. It mixes what we’ve explored with a guess of how far is left (a heuristic), so it usually beelines to the goal while still guaranteeing the shortest path when the heuristic is admissible.
        </div>
        
        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #56ab2f;"></div>
                <span>Start Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #eb3349;"></div>
                <span>End Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #2c3e50;"></div>
                <span>Wall</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #74b9ff;"></div>
                <span>Visited</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ffd700;"></div>
                <span>Shortest Path</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Nodes Visited</span>
                <span class="stat-value" id="nodesVisited">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Path Length</span>
                <span class="stat-value" id="pathLength">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Algorithm Time (real)</span>
                <span class="stat-value" id="algoTime">0ms</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Animation Time (played)</span>
                <span class="stat-value" id="animationTime">0ms</span>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Use:</h3>
            <ul>
                <li>Click on the grid to place Start (green) and End (red) nodes</li>
                <li>Click and drag to draw walls</li>
                <li>Select an algorithm and click <em>Visualize</em> to watch it find the path</li>
                <li>Use <em>Generate Maze</em> for a random maze pattern</li>
                <li>Adjust the <strong>Timescale</strong> (0.1×–20×): lower = slower playback; higher = faster</li>
            </ul>
        </div>
    </div>
    
    <script>
        const ROWS = 20;
        const COLS = 40;
        const BASE_STEP_MS = 25; // 1× playback ≈ old 25ms per step

        const grid = document.getElementById('grid');
        grid.style.gridTemplateColumns = `repeat(${COLS}, 25px)`;
        
        let nodes = [];
        let startNode = null;
        let endNode = null;
        let isMouseDown = false;
        let isRunning = false;
        
        // Descriptions for each algorithm (chatty + clear)
        const ALGO_DESCRIPTIONS = {
            astar: `<strong>A* Search:</strong> the overachiever with a compass. It mixes what we’ve explored with a guess of how far is left (a heuristic), so it usually beelines to the goal while still guaranteeing the shortest path when the heuristic doesn’t overestimate.`,
            dijkstra: `<strong>Dijkstra:</strong> the patient optimizer. It expands outward in all directions with perfectly fair costs, guaranteeing the shortest path—but without any “directional” hint it can explore more nodes than A*.`,
            bfs: `<strong>Breadth-First Search (BFS):</strong> the crowd favorite for uniform costs. It ripples out layer by layer and finds the shortest path when every move costs the same. Simple, reliable, and great for grids like this.`,
            dfs: `<strong>Depth-First Search (DFS):</strong> the spelunker. It dives deep down one corridor before backtracking. Fast to run and fun to watch, but it doesn’t guarantee the shortest path and can wander a lot.`
        };

        // Helpers for timescale-driven animation
        function getTimeScale() {
            return parseFloat(document.getElementById('timescale').value);
        }
        function getMsPerStep() {
            const ms = BASE_STEP_MS / Math.max(getTimeScale(), 0.0001);
            return Math.max(0, ms);
        }

        // Initialize grid
        function initGrid() {
            nodes = [];
            grid.innerHTML = '';
            
            for (let row = 0; row < ROWS; row++) {
                nodes[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    cell.addEventListener('mousedown', () => handleMouseDown(row, col));
                    cell.addEventListener('mouseenter', () => handleMouseEnter(row, col));
                    cell.addEventListener('mouseup', handleMouseUp);
                    
                    grid.appendChild(cell);
                    
                    nodes[row][col] = {
                        row,
                        col,
                        isWall: false,
                        isStart: false,
                        isEnd: false,
                        isVisited: false,
                        distance: Infinity,
                        heuristic: 0,
                        parent: null,
                        element: cell
                    };
                }
            }
            
            // Set default start and end
            startNode = nodes[10][5];
            endNode = nodes[10][35];
            startNode.isStart = true;
            endNode.isEnd = true;
            startNode.element.classList.add('start');
            endNode.element.classList.add('end');
        }
        
        function handleMouseDown(row, col) {
            if (isRunning) return;
            isMouseDown = true;
            toggleNode(row, col);
        }
        
        function handleMouseEnter(row, col) {
            if (!isMouseDown || isRunning) return;
            toggleWall(row, col);
        }
        
        function handleMouseUp() {
            isMouseDown = false;
        }
        
        function toggleNode(row, col) {
            const node = nodes[row][col];
            
            if (!startNode) {
                startNode = node;
                node.isStart = true;
                node.element.classList.add('start');
            } else if (!endNode && node !== startNode) {
                endNode = node;
                node.isEnd = true;
                node.element.classList.add('end');
            } else if (node === startNode) {
                node.isStart = false;
                node.element.classList.remove('start');
                startNode = null;
            } else if (node === endNode) {
                node.isEnd = false;
                node.element.classList.remove('end');
                endNode = null;
            } else {
                toggleWall(row, col);
            }
        }
        
        function toggleWall(row, col) {
            const node = nodes[row][col];
            if (node.isStart || node.isEnd) return;
            
            node.isWall = !node.isWall;
            node.element.classList.toggle('wall');
        }
        
        function clearPath() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const node = nodes[row][col];
                    node.isVisited = false;
                    node.distance = Infinity;
                    node.parent = null;
                    node.element.classList.remove('visited', 'path');
                }
            }
            updateStats(0, 0, 0, 0);
        }
        
        function clearAll() {
            startNode = null;
            endNode = null;
            initGrid();
            updateStats(0, 0, 0, 0);
        }
        
        function generateMaze() {
            clearAll();
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const node = nodes[row][col];
                    if (node.isStart || node.isEnd) continue;
                    
                    if (Math.random() < 0.3) {
                        node.isWall = true;
                        node.element.classList.add('wall');
                    }
                }
            }
        }
        
        function getNeighbors(node) {
            const neighbors = [];
            const { row, col } = node;
            
            if (row > 0) neighbors.push(nodes[row - 1][col]);
            if (row < ROWS - 1) neighbors.push(nodes[row + 1][col]);
            if (col > 0) neighbors.push(nodes[row][col - 1]);
            if (col < COLS - 1) neighbors.push(nodes[row][col + 1]);
            
            return neighbors.filter(n => !n.isWall);
        }
        
        function heuristic(node1, node2) {
            return Math.abs(node1.row - node2.row) + Math.abs(node1.col - node2.col);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function countAnimationSteps(visitedNodes, path) {
            const visitedSteps = visitedNodes.filter(n => !n.isStart && !n.isEnd).length;
            const pathSteps = path.filter(n => !n.isStart && !n.isEnd).length;
            return { visitedSteps, pathSteps, total: visitedSteps + pathSteps };
        }

        function updateStats(visited, pathLength, algoMs, animMs) {
            document.getElementById('nodesVisited').textContent = visited;
            document.getElementById('pathLength').textContent = pathLength;
            document.getElementById('algoTime').textContent = Math.round(algoMs) + 'ms';
            document.getElementById('animationTime').textContent = Math.round(animMs) + 'ms';
        }

        // Dynamic algorithm description
        function updateAlgoBlurb() {
            const key = document.getElementById('algorithm').value;
            document.getElementById('algoBlurb').innerHTML = ALGO_DESCRIPTIONS[key];
        }
        
        async function visualize() {
            if (!startNode || !endNode || isRunning) return;
            
            isRunning = true;
            clearPath();

            const algorithm = document.getElementById('algorithm').value;
            const msPerStep = getMsPerStep();

            const animStart = performance.now();

            let visitedNodes = [];
            let path = [];
            
            switch (algorithm) {
                case 'astar':
                    ({ visitedNodes, path } = await aStar(msPerStep));
                    break;
                case 'dijkstra':
                    ({ visitedNodes, path } = await dijkstra(msPerStep));
                    break;
                case 'bfs':
                    ({ visitedNodes, path } = await bfs(msPerStep));
                    break;
                case 'dfs':
                    ({ visitedNodes, path } = await dfs(msPerStep));
                    break;
            }

            const animEnd = performance.now();
            const animationTime = animEnd - animStart;

            // Estimate "real" algorithm time by subtracting intentional sleeps
            const { visitedSteps, pathSteps, total } = countAnimationSteps(visitedNodes, path);
            const sleepTime = total * msPerStep;
            const algoTime = Math.max(0, animationTime - sleepTime);

            updateStats(visitedNodes.length, path.length, algoTime, animationTime);
            isRunning = false;
        }
        
        async function aStar(msPerStep) {
            const openSet = [startNode];
            const visitedNodes = [];
            startNode.distance = 0;
            startNode.heuristic = heuristic(startNode, endNode);
            
            while (openSet.length > 0) {
                openSet.sort((a, b) => (a.distance + a.heuristic) - (b.distance + b.heuristic));
                const current = openSet.shift();
                
                if (current.isVisited) continue;
                current.isVisited = true;
                visitedNodes.push(current);
                
                if (!current.isStart && !current.isEnd) {
                    current.element.classList.add('visited');
                    await sleep(msPerStep);
                }
                
                if (current === endNode) {
                    const path = await reconstructPath(endNode, msPerStep);
                    return { visitedNodes, path };
                }
                
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const newDistance = current.distance + 1;
                    
                    if (newDistance < neighbor.distance) {
                        neighbor.distance = newDistance;
                        neighbor.heuristic = heuristic(neighbor, endNode);
                        neighbor.parent = current;
                        openSet.push(neighbor);
                    }
                }
            }
            
            return { visitedNodes, path: [] };
        }
        
        async function dijkstra(msPerStep) {
            const unvisited = [];
            startNode.distance = 0;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    unvisited.push(nodes[row][col]);
                }
            }
            
            const visitedNodes = [];
            
            while (unvisited.length > 0) {
                unvisited.sort((a, b) => a.distance - b.distance);
                const current = unvisited.shift();
                
                if (current.distance === Infinity) break;
                
                current.isVisited = true;
                visitedNodes.push(current);
                
                if (!current.isStart && !current.isEnd) {
                    current.element.classList.add('visited');
                    await sleep(msPerStep);
                }
                
                if (current === endNode) {
                    const path = await reconstructPath(endNode, msPerStep);
                    return { visitedNodes, path };
                }
                
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const newDistance = current.distance + 1;
                    
                    if (newDistance < neighbor.distance) {
                        neighbor.distance = newDistance;
                        neighbor.parent = current;
                    }
                }
            }
            
            return { visitedNodes, path: [] };
        }
        
        async function bfs(msPerStep) {
            const queue = [startNode];
            const visitedNodes = [];
            startNode.isVisited = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                visitedNodes.push(current);
                
                if (!current.isStart && !current.isEnd) {
                    current.element.classList.add('visited');
                    await sleep(msPerStep);
                }
                
                if (current === endNode) {
                    const path = await reconstructPath(endNode, msPerStep);
                    return { visitedNodes, path };
                }
                
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (!neighbor.isVisited) {
                        neighbor.isVisited = true;
                        neighbor.parent = current;
                        queue.push(neighbor);
                    }
                }
            }
            
            return { visitedNodes, path: [] };
        }
        
        async function dfs(msPerStep) {
            const stack = [startNode];
            const visitedNodes = [];
            
            while (stack.length > 0) {
                const current = stack.pop();
                
                if (current.isVisited) continue;
                
                current.isVisited = true;
                visitedNodes.push(current);
                
                if (!current.isStart && !current.isEnd) {
                    current.element.classList.add('visited');
                    await sleep(msPerStep);
                }
                
                if (current === endNode) {
                    const path = await reconstructPath(endNode, msPerStep);
                    return { visitedNodes, path };
                }
                
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (!neighbor.isVisited) {
                        neighbor.parent = current;
                        stack.push(neighbor);
                    }
                }
            }
            
            return { visitedNodes, path: [] };
        }
        
        async function reconstructPath(endNode, msPerStep) {
            const path = [];
            let current = endNode;
            
            while (current !== null) {
                path.unshift(current);
                current = current.parent;
            }
            
            for (const node of path) {
                if (!node.isStart && !node.isEnd) {
                    node.element.classList.add('path');
                    await sleep(msPerStep);
                }
            }
            return path;
        }
        
        // Event listeners
        document.getElementById('visualize').addEventListener('click', visualize);
        document.getElementById('generateMaze').addEventListener('click', generateMaze);
        document.getElementById('clearPath').addEventListener('click', clearPath);
        document.getElementById('clearAll').addEventListener('click', clearAll);
        
        document.getElementById('timescale').addEventListener('input', (e) => {
            const scale = parseFloat(e.target.value);
            const approxMs = Math.round(BASE_STEP_MS / Math.max(scale, 0.0001));
            document.getElementById('speedValue').textContent = `${scale.toFixed(1)}× (~${approxMs}ms/step)`;
        });

        document.getElementById('algorithm').addEventListener('change', updateAlgoBlurb);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Initialize
        initGrid();
        updateAlgoBlurb();
    </script>
</body>
</html>
